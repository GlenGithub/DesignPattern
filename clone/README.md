# 原型模式


### 模式定义


 通过前面的简单介绍我们就可以基本确定原型模式的定义了。所谓原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

在原型模式中，所发动创建的对象通过请求原型对象来拷贝原型对象自己来实现创建过程，当然所发动创建的对象需要知道原型对象的类型。这里也就是说所发动创建的对象只需要知道原型对象的类型就可以获得更多的原型实例对象，至于这些原型对象时如何创建的根本不需要关心。






**浅拷贝**：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。

**深拷贝**：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。



### 模式结构

- Prototype：抽象原型类。声明克隆自身的接口。 
- ConcretePrototype：具体原型类。实现克隆的具体操作。 
- Client：客户类。让一个原型克隆自身，从而获得一个新的对象。

java中可以直接使用clone()方法来复制一个对象。但是需要实现clone的Java类必须要实现一个接口:Cloneable.该接口表示该类能够复制且具体复制的能力，如果不实现该接口而直接调用clone()方法会抛出CloneNotSupportedException异常


 Java中任何实现了Cloneable接口的类都可以通过调用clone()方法来复制一份自身然后传给调用者。一般而言，clone()方法满足： 

- 对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。 
- 对任何的对象x，都有x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。 
- 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。



### 优点


- 如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。
- 可以使用深克隆保持对象的状态。
- 原型模式提供了简化的创建结构。
- 运行时刻增加和删除产品： Prototype允许只通过客户注册原型实例就可以将一个新的具体产品类并入系统。它比其他创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。
- 改变值以指定新对象： 高度动态的系统允许你通过对象复合定义新的行为—例如，通过为一个对象变量指定值—并且不定义新的类。你通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。客户可以将职责代理给原型，从而表现出新的行为。这种设计使得用户无需编程即可定义新“类” 。实际上，克隆一个原型类似于实例化一个类。Prototype模式可以极大的减少系统所需要的类的数目。
- 改变结构以指定新对象：许多应用由部件和子部件来创建对象。
- 减少子类的构造 Factory Method 经常产生一个与产品类层次平行的 Creator类层次。Prototype模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象。因此你根本不需要Creator类层次。这一优点主要适用于像 C + +这样不将类作为一级类对象的语言。像Smalltalk和Objective C这样的语言从中获益较少，因为你总是可以用一个类对象作为生成者。在这些语言中，类对象已经起到原型一样的作用了。
- 用类动态配置应用 一些运行时刻环境允许你动态将类装载到应用中。在像 C + +这样的语言中，Prototype模式是利用这种功能的关键。一个希望创建动态载入类的实例的应用不能静态引用类的构造器。而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例（参见实现一节） 。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。 E T + +应用框架[ W G M 8 8 ]有一个运行系统就是使用这一方案的。



### 缺点


- 在实现深克隆的时候可能需要比较复杂的代码。
- 需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。


### 适用场景


- 如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。
- 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。 
- 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。
- 当要实例化的类是在运行时刻指定时，例如，通过动态装载；
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。（也就是当我们在处理一些对象比较简单，并且对象之间的区别很小，可能只是很固定的几个属性不同的时候，可能我们使用原型模式更合适）。



```java

class Address implements Cloneable{

    String country;
    String city;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Address address=(Address) super.clone();
        address.country=this.country;
        address.city=this.city;
        return address;
    }
}
class Student implements Cloneable{
    String name;
    Address address;

    @Override
    protected Object clone()  {
        Student student=null;
        try{
            student=(Student)super.clone();
            student.address=(Address) this.address.clone();
            student.name=this.name;
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return student;
    }
}


public class CloneDemo {
    public static void main(String []args){
        
    }
}

```